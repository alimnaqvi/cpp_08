#include "Span.h"
#include <array>
#include <iostream>
#include <random>

void printSpanInfo( const Span& sp )
{
    std::cout << "Span object with size " << sp.size() << " and capacity " << sp.capacity() << ":\n";
    if ( sp.size() < 150 )
        sp.printElements();
    else
    {
        std::cout << "Showing first 100 elements: ";
        sp.printIndexRange( 0, 99 );
    }
    std::cout << "Shortest span: " << sp.shortestSpan() << ", Longest span: " << sp.longestSpan() << "\n\n";
}

std::vector<int> generateRandomVector( std::size_t size, int rangeFrom, int rangeTo )
{
    // Seed our Mersenne Twister using a pseudo-random number generated by the OS
    std::mt19937 mt{ std::random_device{}() };

    // Create a reusable random number generator that generates uniform numbers between rangeFrom and rangeTo
    std::uniform_int_distribution random{ rangeFrom, rangeTo };

    // Fill a vector with random numbers and return it
    std::vector<int> vec;
    vec.reserve( size );
    for ( std::size_t i{ 0 }; i < size; ++i )
        vec.push_back( random( mt ) );

    return vec;
}

int main()
{
    // Simple tests with 7 numbers
    std::cout << "Simple tests with 7 numbers:" << '\n';
    try
    {
        // Shortest span is 5 and longest span is 75
        std::vector vec{ -20, 50, -25, 0, 10, 20, -10 };

        // Capacity 10 (enough to add all 7)
        Span a{ 10 };

        // Add all using addNumber
        for ( const auto& elem : vec )
            a.addNumber( elem );

        std::cout << "Added using addNumber:" << '\n';
        printSpanInfo( a );

        // Capacity 7 (enough to add all 7)
        Span b{ 10 };

        // Add all using addRange
        b.addRange( vec.begin(), vec.end() );

        std::cout << "Added using addRange:" << '\n';
        printSpanInfo( b );

        // Capacity 5 (too small to add all)
        Span c{ 5 };
        for ( const auto& elem : vec )
        {
            std::cout << "Span c has capacity " << c.capacity() << " and size " << c.size()
                      << " before attempting to add " << elem << " to it." << '\n';
            c.addNumber( elem );
        }

        std::cout << "This won't be reached since above will throw an exception" << '\n';
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Default initialization (implicitly 0 capacity)
    std::cout << "Default initialization (implicitly 0 capacity):" << '\n';
    try
    {
        Span a;

        // Can't add anything to it since it has capacity 0
        a.addNumber( 42 );

        std::cout << "This won't be reached since the above will throw an exception" << '\n';
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Initialize with 0 capacity
    std::cout << "Initialize with 0 capacity:" << '\n';
    try
    {
        Span a{ 0 };

        // Can't determine span since it has capacity 0
        printSpanInfo( a );

        std::cout << "This won't be reached since the above will throw an exception" << '\n';
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Capacity of 1
    std::cout << "Capacity of 1:" << '\n';
    try
    {
        Span a{ 1 };

        a.addNumber( 10 );

        // Can't determine span since it has size 1
        printSpanInfo( a );

        std::cout << "This won't be reached since the above will throw an exception" << '\n';
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Only two values (same shortest/longest span and 0 shortest span)
    std::cout << "Only two values (same shortest/longest span and 0 shortest span):" << '\n';
    try
    {
        Span a{ 200 };

        a.addNumber( 80 );
        a.addNumber( 40 );

        // Only two numbers always have the same shortest and longest span
        printSpanInfo( a );

        for ( int i{ 0 }; i < 100; ++i )
            a.addNumber( i % 2 ? 40 : 80 );

        // 102 numbers now but only two values so still the same shortest and longest span
        printSpanInfo( a );
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // addRange boundary tests
    std::cout << "addRange boundary and iterator type tests:" << '\n';
    try
    {
        Span a{ 100 };

        // A vector of size 50 (all ones)
        std::vector<int> vec( 50 );
        vec.assign( 50, 1 );

        // Add the entire vector to our Span
        a.addRange( vec.begin(), vec.end() );

        // An array of size 50 (fill with twos)
        std::array<int, 50> arr;
        arr.fill( 2 );

        // Add the entire array to our Span
        a.addRange( arr.begin(), arr.end() );

        // Our span should now be at maximum capacity
        printSpanInfo( a );

        Span b{ 49 };

        // Cannot add vec or arr since they are of size 50
        b.addRange( arr.begin(), arr.end() );
        printSpanInfo( b );

        std::cout << "This won't be reached since the above will throw an exception" << '\n';
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Adding 1 million numbers
    std::cout << "Adding 1 million numbers:" << '\n';
    try
    {
        constexpr int total{ 1000000 };

        {
            Span a{ total };

            std::cout << "Ordered array:" << '\n';
            auto arrOrdered{ new std::array<int, total> };
            for ( int i{ 0 }; i < total; ++i )
                ( *arrOrdered )[i] = i + 1;

            a.addRange( arrOrdered->begin(), arrOrdered->end() );

            delete arrOrdered;

            printSpanInfo( a );
        }

        {
            Span b{ total };

            std::cout << "Reverse ordered array:" << '\n';
            auto arrReverse{ new std::array<int, total> };
            for ( int i{ 0 }; i < total; ++i )
                ( *arrReverse )[i] = total - i;

            b.addRange( arrReverse->begin(), arrReverse->end() );

            delete arrReverse;

            printSpanInfo( b );
        }

        // {
        //     Span c{ total };
        //     int  intMin{ std::numeric_limits<int>::min() };
        //     int  intMax{ std::numeric_limits<int>::max() };

        //     std::cout << "Random vector:" << '\n';
        //     std::vector<int> vecRandom{ generateRandomVector( total, intMin, intMax ) };

        //     c.addRange( vecRandom.begin(), vecRandom.end() );

        //     printSpanInfo( c );
        // }
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Test with longestSpan being UINT_MAX (because both INT_MAX and INT_MIN are elements)
    std::cout << "Test with longestSpan being UINT_MAX:" << '\n';
    try
    {
        {
            Span a{ 100 };

            int intMin{ std::numeric_limits<int>::min() };
            int intMax{ std::numeric_limits<int>::max() };

            // All zeros except INT_MAX and INT_MIN
            std::vector<int> vec( 100 );
            vec[0]  = intMax;
            vec[99] = intMin;

            a.addRange( vec.begin(), vec.end() );

            printSpanInfo( a );
        }

        {
            Span a{ 100 };

            int intMin{ std::numeric_limits<int>::min() };
            int intMax{ std::numeric_limits<int>::max() };

            // 98 random numbers with INT_MAX and INT_MIN
            std::vector<int> vec{ generateRandomVector( 100, intMin, intMax ) };
            vec[0]  = intMax;
            vec[99] = intMin;

            a.addRange( vec.begin(), vec.end() );

            printSpanInfo( a );
        }
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Stack copy tests (copy constructor and assignment operator)
    std::cout << "Stack copy tests:" << '\n';
    try
    {
        Span a{ 20 };

        a.addNumber( 1 );
        a.addNumber( 2 );
        a.addNumber( 3 );

        printSpanInfo( a );

        std::cout << "Copying above Span object into a const Span using copy constructor and modifying the original:"
                  << '\n';

        const Span b{ a };

        a.addNumber( 4 );
        a.addNumber( 5 );
        a.addNumber( 6 );

        printSpanInfo( b );

        std::cout << "Original now:" << '\n';

        printSpanInfo( a );

        Span c{ 20 };
        c.addNumber( -1 );
        c.addNumber( -2 );
        c.addNumber( -3 );

        std::cout << "New span object to be replaced by another via copy assignment:" << '\n';
        printSpanInfo( c );

        std::cout << "Copying into above Span object using copy assignment and modifying the original:" << '\n';
        c = a;
        a.addNumber( 7 );
        printSpanInfo( c );
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    // Heap copy tests (copy constructor and assignment operator)
    std::cout << "Heap copy tests:" << '\n';
    try
    {

        Span* a{ new Span{ 50 } };

        std::array primes{ 2, 3, 5, 7, 11, 13, 17 };

        a->addRange( primes.begin(), primes.end() );

        printSpanInfo( *a );

        std::cout << "Copying above Span object using copy constructor and deleting the original:" << '\n';

        Span* b{ new Span{ *a } };

        delete a;

        printSpanInfo( *b );

        std::cout << "Copying above Span object using copy assignment and deleting the original:" << '\n';

        Span c;

        c = *b;

        delete b;

        printSpanInfo( c );
    }
    catch ( const std::exception& e )
    {
        std::cout << "An exception occurred: " << e.what() << '\n';
    }
    std::cout << "-------------------------" << '\n';

    return 0;
}

// int main()
// {
//     Span sp = Span( 5 );

//     sp.addNumber( 6 );
//     sp.addNumber( 3 );
//     sp.addNumber( 17 );
//     sp.addNumber( 9 );
//     sp.addNumber( 11 );

//     std::cout << sp.shortestSpan() << std::endl;
//     std::cout << sp.longestSpan() << std::endl;

//     return 0;
// }
